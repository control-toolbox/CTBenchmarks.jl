var documenterSearchIndex = {"docs":
[{"location":"api.html#API","page":"API","title":"API","text":"","category":"section"},{"location":"api.html","page":"API","title":"API","text":"Pages   = [\"api.md\"]\nModules = [CTBenchmarks]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"api.html#CTBenchmarks.benchmark-Tuple{}","page":"API","title":"CTBenchmarks.benchmark","text":"benchmark(;\n    outpath,\n    problems,\n    solver_models,\n    grid_sizes,\n    disc_methods,\n    tol,\n    ipopt_mu_strategy,\n    print_trace,\n    max_iter,\n    max_wall_time,\n    grid_size_max_cpu\n) -> String\n\nRun benchmarks on optimal control problems and save results to a JSON file.\n\nThis function performs the following steps:\n\nDetects CUDA availability and filters out :exa_gpu if CUDA is not functional\nRuns benchmarks using benchmark_data() to generate a DataFrame of results\nCollects environment metadata (Julia version, OS, machine, timestamp)\nBuilds a JSON-friendly payload combining results and metadata\nSaves the payload to outpath as pretty-printed JSON\n\nThe JSON file can be easily loaded and converted back to a DataFrame using:\n\nusing JSON, DataFrames\ndata = JSON.parsefile(\"path/to/data.json\")\ndf = DataFrame(data[\"results\"])\n\nArguments\n\noutpath: Path to save the JSON file\nproblems: Vector of problem names (Symbols)\nsolver_models: Vector of Pairs mapping solver => models (e.g., [:ipopt => [:JuMP, :adnlp], :madnlp => [:exa, :exa_gpu]])\ngrid_sizes: Vector of grid sizes (Int)\ndisc_methods: Vector of discretization methods (Symbols)\ntol: Solver tolerance (Float64)\nipopt_mu_strategy: Mu strategy for Ipopt (String)\nprint_trace: Boolean - whether to print solver output (for debugging)\nmax_iter: Maximum number of iterations (Int)\nmax_wall_time: Maximum wall time in seconds (Float64)\ngrid_size_max_cpu: Maximum grid size for CPU models (Int)\n\nReturns\n\nThe outpath of the saved JSON file.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTBenchmarks.benchmark_data-Tuple{}","page":"API","title":"CTBenchmarks.benchmark_data","text":"benchmark_data(;\n    problems,\n    solver_models,\n    grid_sizes,\n    disc_methods,\n    tol,\n    ipopt_mu_strategy,\n    print_trace\n    max_iter,\n    max_wall_time,\n    grid_size_max_cpu\n) -> DataFrame\n\nRun benchmarks on optimal control problems and return results as a DataFrame.\n\nFor each combination of problem, solver, model, and grid size, this function:\n\nSets up and solves the optimization problem\nCaptures timing and memory statistics using @btimed or CUDA.@timed\nExtracts solver statistics (objective value, iterations)\nStores all data in a DataFrame row\n\nArguments\n\nproblems: Vector of problem names (Symbols)\nsolver_models: Vector of Pairs mapping solver => models (e.g., [:ipopt => [:JuMP, :adnlp], :madnlp => [:exa, :exa_gpu]])\ngrid_sizes: Vector of grid sizes (Int)\ndisc_methods: Vector of discretization methods (Symbols)\ntol: Solver tolerance (Float64)\nipopt_mu_strategy: Mu strategy for Ipopt (String)\nprint_trace: Boolean - whether to print solver output (for debugging)\nmax_iter: Maximum number of iterations (Int)\nmax_wall_time: Maximum wall time in seconds (Float64)\n\nReturns\n\nA DataFrame with columns:\n\nproblem: Symbol - problem name\nsolver: Symbol - solver used (:ipopt or :madnlp)\nmodel: Symbol - model type (:JuMP, :adnlp, :exa, or :exa_gpu)\ndisc_method: Symbol - discretization method\ngrid_size: Int - number of grid points\ntol: Float64 - solver tolerance\nmu_strategy: Union{String, Missing} - mu strategy for Ipopt (missing for MadNLP)\nprint_level: Any - print level for solver (Int for Ipopt, MadNLP.LogLevels for MadNLP)\nmax_iter: Int - maximum number of iterations\nmax_wall_time: Float64 - maximum wall time in seconds\nbenchmark: NamedTuple - full benchmark object from @btimed or CUDA.@timed\nobjective: Union{Float64, Missing} - objective function value (missing if failed)\niterations: Union{Int, Missing} - number of solver iterations (missing if failed)\nstatus: Any - termination status (type depends on solver/model)\nsuccess: Bool - whether the solve succeeded\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTBenchmarks.build_payload-Tuple{DataFrames.DataFrame, Dict}","page":"API","title":"CTBenchmarks.build_payload","text":"build_payload(results::DataFrame, meta::Dict) -> Dict\n\nCombine benchmark results DataFrame and metadata into a JSON-friendly dictionary. The DataFrame is converted to a vector of dictionaries (one per row) for easy JSON serialization and reconstruction.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTBenchmarks.filter_models_for_backend-Tuple{Vector{Symbol}, Symbol}","page":"API","title":"CTBenchmarks.filter_models_for_backend","text":"filter_models_for_backend(models::Vector{Symbol}, disc_method::Symbol) -> Vector{Symbol}\n\nFilter solver models depending on backend availability and discretization support.\n\nGPU models (ending with _gpu) are kept only if CUDA is available.\nJuMP models are kept only when disc_method == :trapeze.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTBenchmarks.format_benchmark_line-Tuple{Symbol, NamedTuple}","page":"API","title":"CTBenchmarks.format_benchmark_line","text":"format_benchmark_line(model::Symbol, stats::NamedTuple) -> String\n\nBuild a formatted line summarizing benchmark statistics for model. Handles both CPU benchmarks (from @btimed) and GPU benchmarks (from CUDA.@timed).\n\nDisplays: time, allocations/memory, objective, iterations, and success status\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTBenchmarks.generate_metadata-Tuple{}","page":"API","title":"CTBenchmarks.generate_metadata","text":"generate_metadata() -> Dict{String, String}\n\nReturn metadata about the current environment:\n\ntimestamp (UTC, ISO8601)\njulia_version\nos\nmachine hostname\npkg_status - output of Pkg.status() with ANSI colors\nversioninfo - output of versioninfo() with ANSI colors\npkg_manifest - output of Pkg.status(mode=PKGMODE_MANIFEST) with ANSI colors\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTBenchmarks.is_cuda_on-Tuple{}","page":"API","title":"CTBenchmarks.is_cuda_on","text":"is_cuda_on() -> Bool\n\nReturn true if CUDA is functional on this machine.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTBenchmarks.prettymemory-Tuple{Any}","page":"API","title":"CTBenchmarks.prettymemory","text":"prettymemory(bytes::Integer) -> String\n\nFormat a memory footprint bytes into a human-readable string using binary prefixes (bytes, KiB, MiB, GiB) with two decimal places.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTBenchmarks.prettytime-Tuple{Any}","page":"API","title":"CTBenchmarks.prettytime","text":"prettytime(t::Real) -> String\n\nFormat a duration t expressed in seconds into a human-readable string with three decimal places and adaptive units (ns, Î¼s, ms, s).\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTBenchmarks.run","page":"API","title":"CTBenchmarks.run","text":"Run the benchmarks for a specific version.\n\nArguments\n\nversion::Symbol: version to run (:complete or :minimal)\noutpath::Union{AbstractString, Nothing}: directory path to save results (nothing for no saving)\nprint_trace::Bool: whether to print the trace of the solver\n\nReturns\n\nnothing\n\n\n\n\n\n","category":"function"},{"location":"api.html#CTBenchmarks.sanitize_for_json-Tuple{Any}","page":"API","title":"CTBenchmarks.sanitize_for_json","text":"sanitize_for_json(obj)\n\nRecursively replace NaN and Inf values with null for JSON compatibility.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTBenchmarks.save_json-Tuple{Dict, AbstractString}","page":"API","title":"CTBenchmarks.save_json","text":"save_json(payload::Dict, outpath::AbstractString)\n\nSave a JSON payload to a file. Creates the parent directory if needed. Uses pretty printing for readability. Sanitizes NaN and Inf values to null for JSON compatibility.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTBenchmarks.set_print_level-Tuple{Symbol, Bool}","page":"API","title":"CTBenchmarks.set_print_level","text":"set_print_level(solver::Symbol, print_trace::Bool) -> Int\n\nSet print level based on solver and print_trace flag.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTBenchmarks.solve_and_extract_data-Tuple{Symbol, Symbol, Symbol, Int64, Symbol, Float64, Union{Missing, String}, Bool, Int64, Float64}","page":"API","title":"CTBenchmarks.solve_and_extract_data","text":"solve_and_extract_data(problem, solver, model, grid_size, disc_method, \n                      tol, mu_strategy, print_level, max_iter, max_wall_time) -> NamedTuple\n\nSolve an optimal control problem and extract performance and solver statistics.\n\nThis internal helper function handles the solve process and data extraction for different model types (JuMP, adnlp, exa, exa_gpu).\n\nArguments\n\nproblem::Symbol: problem name (e.g., :beam, :chain)\nsolver::Symbol: solver to use (:ipopt or :madnlp)\nmodel::Symbol: model type (:JuMP, :adnlp, :exa, or :exa_gpu)\ngrid_size::Int: number of grid points\ndisc_method::Symbol: discretization method\ntol::Float64: solver tolerance\nmu_strategy::Union{String, Missing}: mu strategy for Ipopt (missing for MadNLP)\nprint_level::Union{Int, MadNLP.LogLevels, Missing}: print level for solver (Int for Ipopt, MadNLP.LogLevels for MadNLP)\nmax_iter::Int: maximum number of iterations\nmax_wall_time::Float64: maximum wall time in seconds\n\nReturns\n\nA NamedTuple with fields:\n\nbenchmark: full benchmark object from @btimed (CPU) or CUDA.@timed (GPU)\nobjective::Union{Float64, Missing}: objective function value (missing if failed)\niterations::Union{Int, Missing}: number of solver iterations (missing if failed)\nstatus::Any: termination status (type depends on solver/model)\nsuccess::Bool: whether the solve succeeded\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTBenchmarks.strip_benchmark_value-Tuple{Any}","page":"API","title":"CTBenchmarks.strip_benchmark_value","text":"strip_benchmark_value(bench)\n\nRemove the value field from benchmark outputs (NamedTuple or Dict) to ensure JSON-serializable data while preserving all other statistics.\n\n\n\n\n\n","category":"method"},{"location":"benchmark-core.html#Core-benchmark","page":"Core benchmark","title":"Core benchmark","text":"","category":"section"},{"location":"benchmark-core.html#Ubuntu-Latest","page":"Core benchmark","title":"Ubuntu Latest","text":"","category":"section"},{"location":"benchmark-core.html","page":"Core benchmark","title":"Core benchmark","text":"This benchmark suite evaluates 14 optimal control problems on a standard CPU platform using GitHub Actions runners.","category":"page"},{"location":"benchmark-core.html","page":"Core benchmark","title":"Core benchmark","text":"Benchmark Configuration:","category":"page"},{"location":"benchmark-core.html","page":"Core benchmark","title":"Core benchmark","text":"Solvers: Ipopt and MadNLP\nModels: JuMP, ADNLPModels, ExaModels (CPU)\nGrid sizes: 200, 500, 1000 discretisation points\nDiscretisation: Trapeze method\nTolerance: 1e-6\nIpopt strategy: Adaptive barrier parameter\nLimits: 1000 iterations max, 500s wall time","category":"page"},{"location":"benchmark-core.html","page":"Core benchmark","title":"Core benchmark","text":"This configuration focuses on CPU-based solvers and provides a comprehensive comparison across different modelling frameworks.","category":"page"},{"location":"benchmark-core.html#Environment","page":"Core benchmark","title":"ð¥ï¸ Environment","text":"","category":"section"},{"location":"benchmark-core.html","page":"Core benchmark","title":"Core benchmark","text":"_basic_metadata(BENCH_DATA_UBUNTU) # hide","category":"page"},{"location":"benchmark-core.html","page":"Core benchmark","title":"Core benchmark","text":"_downloads_toml(BENCH_DIR_UBUNTU) # hide","category":"page"},{"location":"benchmark-core.html","page":"Core benchmark","title":"Core benchmark","text":"<details style=\"margin-bottom: 0.5em; margin-top: 0.5em;\"><summary>â¹ï¸ Version info</summary>","category":"page"},{"location":"benchmark-core.html","page":"Core benchmark","title":"Core benchmark","text":"_bench_data(BENCH_DATA_UBUNTU) # hide","category":"page"},{"location":"benchmark-core.html","page":"Core benchmark","title":"Core benchmark","text":"</details>","category":"page"},{"location":"benchmark-core.html","page":"Core benchmark","title":"Core benchmark","text":"<details style=\"margin-bottom: 0.5em;\"><summary>ð¦ Package status</summary>","category":"page"},{"location":"benchmark-core.html","page":"Core benchmark","title":"Core benchmark","text":"_package_status(BENCH_DATA_UBUNTU) # hide","category":"page"},{"location":"benchmark-core.html","page":"Core benchmark","title":"Core benchmark","text":"</details>","category":"page"},{"location":"benchmark-core.html","page":"Core benchmark","title":"Core benchmark","text":"<details style=\"margin-bottom: 0.5em;\"><summary>ð Complete manifest</summary>","category":"page"},{"location":"benchmark-core.html","page":"Core benchmark","title":"Core benchmark","text":"_complete_manifest(BENCH_DATA_UBUNTU) # hide","category":"page"},{"location":"benchmark-core.html","page":"Core benchmark","title":"Core benchmark","text":"</details>","category":"page"},{"location":"benchmark-core.html#Results","page":"Core benchmark","title":"ð Results","text":"","category":"section"},{"location":"benchmark-core.html","page":"Core benchmark","title":"Core benchmark","text":"_print_results(BENCH_DATA_UBUNTU) # hide\nnothing # hide","category":"page"},{"location":"benchmark-core.html#Moonshot","page":"Core benchmark","title":"Moonshot","text":"","category":"section"},{"location":"benchmark-core.html","page":"Core benchmark","title":"Core benchmark","text":"This benchmark suite evaluates 14 optimal control problems on GPU-accelerated hardware, focusing on large-scale problems.","category":"page"},{"location":"benchmark-core.html","page":"Core benchmark","title":"Core benchmark","text":"Benchmark Configuration:","category":"page"},{"location":"benchmark-core.html","page":"Core benchmark","title":"Core benchmark","text":"Solver: MadNLP (GPU-optimised)\nModels: ExaModels (CPU), ExaModels (GPU)\nGrid sizes: 1000, 5000, 10000 discretisation points\nDiscretisation: Trapeze method\nTolerance: 1e-6\nLimits: 1000 iterations max, 1000s wall time","category":"page"},{"location":"benchmark-core.html","page":"Core benchmark","title":"Core benchmark","text":"This configuration demonstrates GPU acceleration capabilities with ExaModels on large-scale problems, comparing CPU vs GPU performance for the same modelling framework.","category":"page"},{"location":"benchmark-core.html#Environment-2","page":"Core benchmark","title":"ð Environment","text":"","category":"section"},{"location":"benchmark-core.html","page":"Core benchmark","title":"Core benchmark","text":"_basic_metadata(BENCH_DATA_MOONSHOT) # hide","category":"page"},{"location":"benchmark-core.html","page":"Core benchmark","title":"Core benchmark","text":"_downloads_toml(BENCH_DIR_MOONSHOT) # hide","category":"page"},{"location":"benchmark-core.html","page":"Core benchmark","title":"Core benchmark","text":"<details style=\"margin-bottom: 0.5em; margin-top: 0.5em;\"><summary>â¹ï¸ Version info</summary>","category":"page"},{"location":"benchmark-core.html","page":"Core benchmark","title":"Core benchmark","text":"_bench_data(BENCH_DATA_MOONSHOT) # hide","category":"page"},{"location":"benchmark-core.html","page":"Core benchmark","title":"Core benchmark","text":"</details>","category":"page"},{"location":"benchmark-core.html","page":"Core benchmark","title":"Core benchmark","text":"<details style=\"margin-bottom: 0.5em;\"><summary>ð¦ Package status</summary>","category":"page"},{"location":"benchmark-core.html","page":"Core benchmark","title":"Core benchmark","text":"_package_status(BENCH_DATA_MOONSHOT) # hide","category":"page"},{"location":"benchmark-core.html","page":"Core benchmark","title":"Core benchmark","text":"</details>","category":"page"},{"location":"benchmark-core.html","page":"Core benchmark","title":"Core benchmark","text":"<details style=\"margin-bottom: 0.5em;\"><summary>ð Complete manifest</summary>","category":"page"},{"location":"benchmark-core.html","page":"Core benchmark","title":"Core benchmark","text":"_complete_manifest(BENCH_DATA_MOONSHOT) # hide","category":"page"},{"location":"benchmark-core.html","page":"Core benchmark","title":"Core benchmark","text":"</details>","category":"page"},{"location":"benchmark-core.html#Results-2","page":"Core benchmark","title":"â¡ Results","text":"","category":"section"},{"location":"benchmark-core.html","page":"Core benchmark","title":"Core benchmark","text":"_print_results(BENCH_DATA_MOONSHOT) # hide\nnothing # hide","category":"page"},{"location":"index.html#CTBenchmarks","page":"Introduction","title":"CTBenchmarks","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"CTBenchmarks.jl is a comprehensive benchmarking suite for optimal control problems, designed to evaluate and compare the performance of different solvers and modelling approaches within the control-toolbox ecosystem.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"This package provides:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"ð Pre-configured benchmark suites for quick performance evaluation\nð Automated result collection and analysis\nð§ Flexible API for creating custom benchmarks\nð Detailed performance metrics including timing, memory usage, and solver statistics","category":"page"},{"location":"index.html#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"warning: Development Package\nCTBenchmarks.jl is not yet registered in the Julia General Registry. You must clone the repository to use it.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"To install CTBenchmarks.jl, clone the repository and activate the project:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"using Pkg\n\n# Clone the repository\nPkg.develop(url=\"https://github.com/control-toolbox/CTBenchmarks.jl\")\n\n# Or clone manually and activate\n# git clone https://github.com/control-toolbox/CTBenchmarks.jl.git\n# cd CTBenchmarks.jl\n# julia --project=.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Once installed, load the package:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"using CTBenchmarks","category":"page"},{"location":"index.html#Quick-Start","page":"Introduction","title":"Quick Start","text":"","category":"section"},{"location":"index.html#Running-Pre-configured-Benchmarks","page":"Introduction","title":"Running Pre-configured Benchmarks","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"CTBenchmarks provides two pre-configured benchmark suites:","category":"page"},{"location":"index.html#Minimal-Benchmark-(Fast)","page":"Introduction","title":"Minimal Benchmark (Fast)","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Run a quick benchmark on a single problem to test your setup:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"CTBenchmarks.run(:minimal)","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"This runs the :beam problem with:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Grid size: 100\nDiscretisation: trapeze\nSolvers: Ipopt and MadNLP\nModels: JuMP, adnlp, exa, exa_gpu","category":"page"},{"location":"index.html#Complete-Benchmark-(Comprehensive)","page":"Introduction","title":"Complete Benchmark (Comprehensive)","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Run the full benchmark suite across all problems:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"CTBenchmarks.run(:complete)","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"This runs 14 optimal control problems with:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Grid sizes: 100, 200, 500\nDiscretisations: trapeze, midpoint\nSolvers: Ipopt and MadNLP\nModels: JuMP, adnlp, exa, exa_gpu","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"tip: Solver Output\nBy default, solver output is suppressed. To see detailed solver traces, use:CTBenchmarks.run(:minimal; print_trace=true)","category":"page"},{"location":"index.html#Saving-Results","page":"Introduction","title":"Saving Results","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"To save benchmark results to a directory:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"CTBenchmarks.run(:minimal; outpath=\"my_results\")","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"This creates a directory containing:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"data.json - Benchmark results in JSON format\nProject.toml - Package dependencies\nManifest.toml - Complete dependency tree","category":"page"},{"location":"index.html#Creating-Custom-Benchmarks","page":"Introduction","title":"Creating Custom Benchmarks","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"For more control over your benchmarks, use the CTBenchmarks.benchmark function directly:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"CTBenchmarks.benchmark(;\n    outpath = \"custom_benchmark\",\n    problems = [:beam, :chain, :robot],\n    solver_models = [\n        :ipopt => [:JuMP, :adnlp, :exa],\n        :madnlp => [:exa, :exa_gpu]\n    ],\n    grid_sizes = [200, 500, 1000],\n    disc_methods = [:trapeze],\n    tol = 1e-6,\n    ipopt_mu_strategy = \"adaptive\",\n    print_trace = false,\n    max_iter = 1000,\n    max_wall_time = 500.0\n)","category":"page"},{"location":"index.html#Available-Problems","page":"Introduction","title":"Available Problems","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"CTBenchmarks includes 14 optimal control problems from OptimalControlProblems.jl:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":":beam - Beam control problem\n:chain - Chain of masses\n:double_oscillator - Double oscillator\n:ducted_fan - Ducted fan control\n:electric_vehicle - Electric vehicle optimisation\n:glider - Glider trajectory\n:insurance - Insurance problem\n:jackson - Jackson problem\n:robbins - Robbins problem\n:robot - Robot arm control\n:rocket - Rocket trajectory\n:space_shuttle - Space shuttle re-entry\n:steering - Steering control\n:vanderpol - Van der Pol oscillator","category":"page"},{"location":"index.html#Solver-and-Model-Combinations","page":"Introduction","title":"Solver and Model Combinations","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Supported Solvers:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":":ipopt - Interior Point Optimizer\n:madnlp - Matrix-free Augmented Lagrangian NLP solver","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Supported Models:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":":JuMP - JuMP modelling framework\n:adnlp - Automatic differentiation NLP models\n:exa - ExaModels (CPU)\n:exa_gpu - ExaModels (GPU acceleration)","category":"page"},{"location":"index.html#Benchmark-Parameters","page":"Introduction","title":"Benchmark Parameters","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"grid_sizes: Number of discretisation points (e.g., [100, 200, 500])\ndisc_methods: Discretisation schemes (:trapeze, :midpoint)\ntol: Solver tolerance (default: 1e-6)\nmax_iter: Maximum solver iterations (default: 1000)\nmax_wall_time: Maximum wall time in seconds (default: 500.0)","category":"page"},{"location":"index.html#Benchmark-Results-in-This-Documentation","page":"Introduction","title":"Benchmark Results in This Documentation","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"This documentation includes pre-computed benchmark results from continuous integration runs on different platforms:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Ubuntu Latest - Standard CPU benchmarks on GitHub Actions runners\nMoonshot - GPU-accelerated benchmarks on dedicated hardware","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"These results provide reference performance data and demonstrate the capabilities of different solver and model combinations. You can explore them in the Core Benchmark section.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Each benchmark result page includes:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"ð Performance metrics (time, memory, iterations)\nð¥ï¸ Environment information (Julia version, OS, hardware)\nð Reproducible benchmark scripts\nð¦ Complete dependency information","category":"page"},{"location":"index.html#Understanding-Benchmark-Output","page":"Introduction","title":"Understanding Benchmark Output","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"When you run a benchmark, you'll see output similar to:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Benchmarks results:\n\nââ problem: beam\nâ\nââââ¬ solver: ipopt, disc_method: trapeze\nâ  â\nâ  â  N : 100\nâ  â  â | JuMP    :    1.234 s | obj: 1.234567e+00 | iters: 42    | CPU:    2.5 MiB\nâ  â  â | adnlp   :    0.987 s | obj: 1.234567e+00 | iters: 42    | CPU:    2.1 MiB\nâ  â  â | exa     :    0.765 s | obj: 1.234567e+00 | iters: 42    | CPU:    1.8 MiB\nâ  ââ\nââ","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Legend:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"â / â - Success or failure indicator\nTime - Total solve time (right-aligned for easy comparison)\nobj - Objective function value\niters - Number of solver iterations\nMemory - CPU memory usage (GPU memory shown separately for GPU models)","category":"page"},{"location":"index.html#Documentation-build-environment","page":"Introduction","title":"Documentation build environment","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"_downloads_toml(\".\") # hide","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"<details style=\"margin-bottom: 0.5em; margin-top: 1em;\"><summary>â¹ï¸ Version info</summary>","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"versioninfo() # hide","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"</details>","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"<details style=\"margin-bottom: 0.5em;\"><summary>ð¦ Package status</summary>","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Pkg.status() # hide","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"</details>","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"<details style=\"margin-bottom: 0.5em;\"><summary>ð Complete manifest</summary>","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Pkg.status(; mode = PKGMODE_MANIFEST) # hide","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"</details>","category":"page"}]
}
